## 概念题

#### 一. 请阐述C++中动态绑定和静态绑定的概念，并说明在什么情况下会发生动态绑定。

* 静态绑定：在编译时期确定的，绑定的对象的静态类型，即对象指针/引用被声明的类型。
* 动态绑定：在运行时动态确定的， 绑定的对象的动态类型，即对象指针/引用实际指向/引用对象的类型。
* 发生动态绑定的条件：
    * 通过基类的**指针**或**引用**访问基类的**虚函数**时，会发生动态绑定，绑定到实际指向或引用的对象类型。
    * 在**构造函数**和**析构函数**中对于虚函数的调用不进行动态绑定。
    * 函数参数的**默认值**不进行动态绑定。



## 编程题

#### 一.

结果：

```cpp
//m1构造
member construct										//m1定义
//m2构造
member construct										//m2定义
//d1构造
member copy construct									//mm1构造，值传递
member copy construct									//mm2构造，值传递
base construct											//d1基类构造
member copy construct									//d1成员对象构造
member copy construct									//d1成员对象构造
derived construct										//d1自身构造
member destruct											//mm1析构
member destruct											//mm2析构
//d2构造
base construct											//d2基类构造
member construct										//d2成员对象构造
menber construct										//d2成员对象构造
derived copy construct									//d2自身构造
//d2析构
derived destruct										//d2自身析构
member destruct											//d2成员对象析构
member destruct											//d2成员对象析构
base destruct											//d2基类析构
//d1析构
derived destruct										//d1自身析构
member destruct											//d1成员对象析构
member destruct											//d1成员对象析构
base destruct											//d1基类析构
//m2析构
member destruct											//m2析构
//m1析构
member destruct											//m1析构
```



#### 二. 

* `Motor`类与`Engine`类间的关系：**聚类**，`Engine`内部拥有`Motor`成员对象
* `Motor`类与`AdvancedMotor`类间的关系：**继承**，`AdvancedMotor`类继承`Motor`类

代码：

```cpp
#include<iostream>
using namespace std;

#define MAX_OIL 100

enum Quality{
    UNKNOWN, BAD, NORMAL, GOOD
};

class Engine {
protected:
    double oil;
    Quality quality;
public:
    Engine(){}
    Engine(double initOil): oil(initOil), quality(UNKNOWN){}
    Engine(double initOil, Quality initQuality): oil(initOil), quality(initQuality){}
    bool open(){
        return true;
    }
    bool close(){
        return false;
    }
    bool addoil(double addOil){
        if(oil + addOil <= MAX_OIL){
            oil += addOil;
            return true;
        }
        return false;
    }
    bool start(){
        return true;
    }
    bool stop(){
        return true;
    }
    double display(){
        return oil;
    }
    bool checkoil(){
        return (quality == GOOD);
    }
};

class Motor {
protected:
    Engine e;
public:
    Motor(double initOil): e(initOil){}
    Motor(double initOil, Quality initQuality): e(initOil, initQuality){}
    bool addoil(double addOil){                             //摩托车加油成功需要引擎三步都成功
        if(e.open() && e.addoil(addOil) && e.close()){
            return true;
        }
        return false;
    }
    bool run(){                                             //摩托车开动
        return (e.start() && e.stop());
    }
};

class AdvancedMotor :public Motor{
private:
    
public:
    AdvancedMotor(double initOil, Quality initQuality): Motor(initOil, initQuality){}
    double display(){
        return e.display();
    }
    bool checkoil(){
        return e.checkoil();
    }
};

int main(){
    AdvancedMotor ad(20, GOOD);
    cout << ad.display() << endl;
    ad.addoil(200);
    cout << ad.display() << endl;
    ad.addoil(50);
    cout << ad.display() << endl;
    cout << ad.checkoil() << endl;

    Motor m(10);
    m.addoil(20);
    m.run();
}
```



#### 三.

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class A{
private:
    int x;
public:
    A(int x){
        this->x = x;
    }
    A& operator=(const A& a){           //定义基类拷贝构造函数
        x = a.x;
        return *this;
    }
    int get_x(){
        return x;
    }
};

class B: public A{
private:
    char* str;
public:
    B(int x, int length, char* s):A(x){
        str = new char[length+1];
        for(int i = 0;i<length;i++)
            str[i]=s[i];
        str[length]='\0';
    }
    B& operator=(const B& b){           //定义派生类拷贝构造函数
        this->A::operator=(b);          //调用基类自定义的拷贝构造
        if(str!=NULL){
            delete[] str;
            str = NULL;
        }
        int length = strlen(b.str);
        str = new char[length + 1];
        for(int i = 0;i < length; i++)
            str[i] = (b.str)[i];
        str[length] = '\0';
        return *this;
    }
    ~B(){
        if(str!=NULL){
            delete[] str;
            str = NULL;
        }
    } 
    void print(){
        cout << this->str << "," << this->get_x() << endl;
    }
};

void f(){
    B b1(10, 5, (char*)"Hello"), b2(20, 5, (char*)"World");
    b1.print();
    b2.print();
    b1 = b2;
    b1.print();
    b2.print();
}

int main(){
    f();
    cout<<"Hello World"<<endl;
    return 0;
}/**
Hello,10
World,20
World,20
World,20
Hello World
*/
```

